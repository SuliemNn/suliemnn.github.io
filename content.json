{"posts":[{"title":"自定义实现布隆过滤器","text":"布隆过滤器是一种数据结构，用于快速判断一个元素是否存在于一个集合中。它以牺牲一定的准确性为代价，来降低在大规模数据集中的查询时间。 布隆过滤器利用一系列哈希函数和一个比特数组来实现。当元素被添加到布隆过滤器中时，相应的哈希函数会将其映射到比特数组的多个位置上。查询时，如果元素对应的所有位置都被置为1，则说明元素可能存在于集合中；否则，元素一定不存在。 尽管布隆过滤器具有一定的误判率，但它具有很高的查询速度和空间效率，特别适用于需要快速判断某个元素是否属于一个大规模数据集的场景，比如网络爬虫中的URL去重、缓存中的数据查询等。 在Java中，我们可以通过实现布隆过滤器来有效地处理大规模数据集。使用合适的哈希函数和比特数组大小，可以平衡布隆过滤器的空间占用和查询性能。 在接下来的博客中，我们将深入探讨如何使用Java语言实现布隆过滤器，以及如何在实际应用中有效地利用它来提升系统的性能和效率。github链接：YugBloomFilter 介绍快速启动布隆过滤器常用于解决缓存穿透问题，平常我们可以使用Google Guava库中的BloomFilter类、Apache Commons库中的BloomFilter类等来创建布隆过滤器，示例代码如下 123456789101112131415public class BloomFilterExample { public static void main(String[] args) { // 创建布隆过滤器，预期数据量为1000，误判率为0.01 BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), 1000, 0.01); // 添加元素到布隆过滤器 bloomFilter.put(123); bloomFilter.put(456); bloomFilter.put(789); // 检查元素是否存在于布隆过滤器中 System.out.println(bloomFilter.mightContain(123)); // true System.out.println(bloomFilter.mightContain(999)); // false }} 原理布隆过滤器可以看作是一个bits为n的ditmap，同时有k个哈希函数。当一个元素加入位图时，通过k个hash函数将元素映射到位图的k个点，并把它们置1；当检索时，再通过k个hash函数运算检查位图的k个点是否都为1；如果有不为1的点，那么认为该key不存在；如果全部为1，则可能存在。同时可能存在误判的情况，即k个点均为1，而实际上该key并不存在布隆过滤器中。布隆过滤器的误判率，主要取决于bitmap的大小和hash函数的个数以及设计。正常我们在使用布隆过滤器的时候，是给定预期数据量n和误判率p，然后动态生成我们所需要的布隆过滤器。计算公式如下：$$m = \\lceil \\frac{n \\cdot \\log(p)}{\\log\\left(\\frac{1}{2^{\\log(2)}}\\right)} \\rceil$$$$k = \\text{round}\\left(\\frac{m}{n} \\cdot \\log(2)\\right)$$得到bitmap的大小m和所需哈希函数个数之后，我们便可以开始构造属于我们的布隆过滤器了 代码实现定义布隆过滤器接口在这里我们定义布隆过滤器的接口类，方便程序的扩展和后续的使用 1234567public interface BloomFilter { //添加元素 public void add(Object value); //判断某元素是否存在 public boolean contains(Object value); } 实现简单布隆过滤器该简单布隆过滤器接受bitma的大小和hash函数的个数以进行初始化 1234567891011121314/** * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样 */public SimpleBloomFilter(int size, int k) { this.size=size; this.k=k; this.bits = new BitSet(size); // 根据k的值获得k个种子数组 SEEDS = PrimeNumbers.getKDistinctPrimes(k); // 根据k个种子创建k个哈希函数并添加到数组中 for(int i : SEEDS){ func.add(new SimpleHash(size,i)); }} 属性定义： 123456789101112131415161718192021222324/** * 位数组的大小 */ private int size; /** * SimpleHash Function 的个数 */ private int k; /** * 通过这个数组可以创建 多 个不同的哈希函数 */ private List&lt;Integer&gt; SEEDS ; /** * 位数组。数组中的元素只能是 0 或者 1 */ private BitSet bits ; /** * 存放包含 hash 函数的类的数组 */ private ArrayList&lt;SimpleHash&gt; func = new ArrayList&lt;&gt;(); 定义哈希类根据上文所述，我们需要k个哈希函数，在此我们定义一个SimpleHash类，给定bitmap容量和随机数种子之后可以动态的生成一个hash函数注意： 需要给定bitmap的容量是因为我们的hash函数生成的hashcode的范围应该在（0,m-1） 种子最好为质数 12345678910111213141516171819public static class SimpleHash { private int cap; private int seed; public SimpleHash(int cap, int seed) { this.cap = cap; this.seed = seed; } /** * 计算 hash 值 */ public int hash(Object value) { int h; return (value == null) ? 0 : Math.abs(seed * (cap - 1) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; 16))); }} 质数生成器我们需要一个相对均匀的质数数组，所以我们实现一个简单的质数生成器，每个质数之间的间隔大于20，以确保它相对来说均匀 12345678910111213141516171819202122232425262728293031public class PrimeNumbers { public static List&lt;Integer&gt; getKDistinctPrimes(int k) { List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); int num = 2; while (primes.size() &lt; k) { if (isPrime(num) &amp;&amp; isWellDistributed(num, primes)) { primes.add(num); } num++; } return primes; } private static boolean isPrime(int num) { /** * 省略代码实现 */ } private static boolean isWellDistributed(int num, List&lt;Integer&gt; primes) { for (int prime : primes) { if (Math.abs(prime - num) &lt; 20) { // 设置一个距离阈值，确保质数之间距离较远 return false; } } return true; }} 实现布隆过滤器接口初始化完毕之后，便需要实现布隆过滤器的接口，实现add和contains功能 12345678910111213141516171819/** * 添加元素到位数组 */public void add(Object value) { for (SimpleHash f : func) { bits.set(f.hash(value), true); }}/** * 判断指定元素是否存在于位数组 */public boolean contains(Object value) { boolean ret = true; for (SimpleHash f : func) { ret = ret &amp;&amp; bits.get(f.hash(value)); } return ret;} 实现布隆过滤器工厂布隆过滤器工厂接收预期数据量n和误差率p，根据上面两个数据计算出布隆过滤器的大小m(size)和哈希函数个数k。通过布隆过滤器工厂创建布隆过滤器可以简化布隆过滤器的使用 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435/** * 布隆过滤器的工厂，用于创建布隆过滤器 * 给定 预期数据量 n 和误差率 p 计算得到所需布隆过滤器的 size 和哈希函数个数 k */public class BloomFilterFactory { /** * 创建普通布隆过滤器 * @param n * @param p * @return */ public static BloomFilter createBloomFilter(int n, double p){ int size = getSizeOfBloomFilter(n,p); int k =getNumberOfHashFuc(size,n); return new SimpleBloomFilter(size,k); } /** * 根据传入的数据量 n 和 误差率 p返回size * @return */ private static int getSizeOfBloomFilter(int n, double p) { int size = (int) Math.ceil(-(n * Math.log(p)) / Math.pow(Math.log(2), 2)); return size; } /** * 根据传入的 size 和 数据量 n 返回所需的哈希函数值 * @return */ private static int getNumberOfHashFuc(int size, int n) { int k = (int) Math.ceil((size / (double) n) * Math.log(2)); return k; }} 程序中实际应用布隆过滤器程序执行逻辑梳理：请求到来之后在Server到Redis之间插入布隆过滤器，先判断数据是否存在，存在再执行接下来的步骤，不存在则直接返回。同时在每次查询到数据结果之后，布隆过滤器添加该key。代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142BloomFilter myBloomFilter = BloomFilterFactory.createBloomFilter(1000,0.001);/** * 初始化布隆过滤器，将数据库中的数据初始化进入布隆过滤器中 */@PostConstructpublic void init(){ List&lt;Shop&gt; shops = shopMapper.selectList(null); for (Shop shop : shops){ myBloomFilter.add(shop.getId()); }}@Overridepublic Result queryById(Long id) { //先从布隆过滤中判断是否有这个数据 if(!myBloomFilter.contains(id)){ return Result.fail(&quot;不包含这个id&quot;); } String key = &quot;cache:shop:&quot; + id; // 1. 从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 2. 判断是否存在 if (StrUtil.isNotBlank(shopJson)){ // 3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); return Result.ok(shop); } // 4.不存在，根据id查询数据库 Shop shop = getById(id); // 5.不存在，返回错误 if (shop == null){ return Result.fail(&quot;商铺不存在！&quot;); } // 6.存在，写入redis,并设置过期时间 stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop)); //设置30+1~5 mins的过期时间，以解决缓存雪崩问题 stringRedisTemplate.expire(key,30+RANDOM_EXPIRE_TIME, TimeUnit.MINUTES); return Result.ok(shop);} 拓展：自扩容布隆过滤器当布隆过滤器实际的数据存储量超过预期数据量之后，误判率也会随之上涨。但是布隆过滤器是不能删除已有元素的，在这里我们采取的方案是再创建一个布隆过滤器添加操作在最新的布隆过滤器中执行，contain操作在所有的布隆过滤器中执行代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 自适应布隆过滤器，当满了的时候实现自动扩容 */public class AdaptBloomFilter implements BloomFilter{ private int n; private double p; public AdaptBloomFilter(int n, double p){ this.n=n; this.p=p; this.bloomList.add(BloomFilterFactory.createBloomFilter(n,p)); } // 布隆过滤器列表 private ArrayList&lt;BloomFilter&gt; bloomList = new ArrayList&lt;&gt;();; //此布隆过滤器实现 private int count=0; @Override public void add(Object value) { // 向最后的一个布隆过滤器添加 bloomList.get(bloomList.size()-1).add(value); if (count++&gt;n){ expand(); } } @Override public boolean contains(Object value) { // 遍历每个布隆过滤器判断是否存在 for (BloomFilter i : bloomList){ if (bloomList.contains(value)){ return true; } } return false; } private void expand(){ this.bloomList.add(BloomFilterFactory.createBloomFilter((int) (n*0.5),p)); }}","link":"/BloomFilter/"},{"title":"适彼乐土的第一篇博客！","text":"你好！这里是适彼乐土的随想空间，在2024年除夕晚上十一点我利用hexo+github pages 我搭建了这篇博客。这篇博客将用于记录我的生活和秋招历程，以及写一些技术文章。欢迎大家持续关注！随缘更新~ 博客主题链接：icarus，不得不说这个主题是真的超级酷！这是我搜罗了整整三个小时才找到的宝藏主题，如果你也想自己搭建博客的话，非常推荐你使用这个主题！hexo搭建博客教程推荐：GitHub+Hexo 搭建个人网站详细教程","link":"/hello-world/"},{"title":"S-AES加密算法","text":"AES（Advanced Encryption Standard）是一种常用的对称加密算法，用于保护数据的安全性。Python提供了丰富的库和模块，使得实现AES加密算法变得简单而高效。通过使用Python中的cryptography库或者pycryptodome库，我们可以轻松地实现AES加密算法，并对数据进行加密和解密操作。 在接下来的博客中，我们将详细介绍如何使用Python语言实现AES加密算法。我们将学习如何生成密钥、执行加密和解密操作，以及如何处理加密数据。通过深入研究Python中AES算法的实现，我们将更好地理解数据加密的原理和实践，从而保障数据的安全性和机密性。github链接：S-AES 流程概述 密钥扩展（Key Expansion）： AES算法使用的密钥长度可以是128位、192位或256位。 首先，根据密钥长度确定迭代次数，然后通过密钥扩展算法生成每一轮加密所需的子密钥。 初始轮（Initial Round）： 将明文分组与初始轮密钥（Round Key）进行XOR运算。 轮运算（Rounds）： AES算法中的加密运算是由多轮执行的，每一轮都包含四个基本步骤：字节代换（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。 字节代换（SubBytes）：通过一个固定的S盒（Substitution Box）将每个字节替换为另一个字节。 行移位（ShiftRows）：对每一行进行循环移位。第一行不变，第二行向左移动一位，第三行向左移动两位，第四行向左移动三位。 列混淆（MixColumns）：将每一列视为多项式，然后与一个固定的矩阵进行乘法，结果取模AES的模多项式。 轮密钥加（AddRoundKey）：每一轮使用的轮密钥与状态矩阵进行逐比特的XOR运算。 最终轮（Final Round）： 在最后一轮中，省略列混淆步骤，只执行字节代换、行移位和轮密钥加。 输出密文（Cipher Text）： 经过多轮处理后的状态矩阵即为加密后的密文。 S-AES的加密与解密步骤拆解定义初始常量初始常量不同，相同的key得到的密钥也不同，所以我们需要先规定一个初始常量。这些常量均可以被公开，而不会影响到密码的安全性。 1234567891011121314151617#轮常数 cons1=&quot;10000000&quot; cons2=&quot;00110000&quot; # 置换盒 S_Box = [['9', '4', 'A', 'B'], ['D', '1', '8', '5'], ['6', '2', '0', '3'], ['C', 'E', 'F', '7']] # 逆置换盒 S_deBox = [['A', '5', '9', 'B'], ['1', '7', '8', 'F'], ['6', '0', '2', '3'], ['C', '4', 'D', 'E']] mixMatrix = [['1', '4'], ['4', '1']] deMixMatrix = [['9', '2'], ['2', '9']] 密钥扩展原来的密钥需要生成多对子密钥，分别作为各轮加密步骤的子密钥。==将16位密钥分为左右两部分，每一部分各8位。记原始密钥为第0个密钥。== 在计算第i个密钥时，首先将第i-1个密钥的右半部分（8位）进行左循环移位，即将第i-1个密钥的右半部分的左右4位进行交换，再将左循环移位后的第i-1个密钥的右半部分（8位）进行S盒置换。 进行S盒置换后需要与轮常数进行异或，S-AES的轮常数定义为：第一轮加密的轮常数是【1000 0000】，第二轮加密的轮常数是【0011 0000】。 上述步骤就是示意图中函数g的步骤，将第i-1个密钥的右半部分（8位）执行完上述步骤后得到g(第i-1个密钥的右半部分)，将其与第i-1个密钥的左半部分（8位）进行异或得到第i个密钥的左半部分。 第i个密钥的右半部分由第i个密钥的左半部分与第i-1个密钥的右半部分进行异或得到。 具体实现： 12345678910111213141516171819202122232425262728293031323334#输入初始密钥，输出扩展之后的密钥 def expandKey(key,cons,Box): rightKey = key[8:] leftKey = key[0:8] # 左边的密钥由右半部分g(i-1)与左半部分异或得到 resLeft=xor(G(rightKey,cons,Box),leftKey) # 第i个密钥的右半部分由第i个密钥的左半部分与第i-1个密钥的右半部分进行异或得到 resRight=xor(resLeft,rightKey) return resLeft+resRight#密钥扩展的g函数， def G(byteText,cons,Box): #第一步进行左循环移位，将左右两个进行互换 resText=byteText[4:]+byteText[0:4] #第二步进行S盒替代 index = 0 result = &quot;&quot; while index &lt; len(resText): i = int(resText[index:index + 2], 2) j = int(resText[index + 2:index + 4], 2) result += Box[i][j] index += 4 # 十六进制转换二进制 result = bin(int(result, 16))[2:].zfill(8) #第三步，与轮常数进行异或 result=xor(result,cons) return result 测试： 12345#密钥扩展确认 cyberText=&quot;1010011100111011&quot; print(&quot;密钥扩展确认&quot;) print(&quot;第一轮加密：&quot; + expandKey(cyberText,cons1,S_Box)) print(&quot;第二轮加密：&quot; + expandKey(expandKey(cyberText,cons1,S_Box), cons2, S_Box)) 结果如下： 123密钥扩展确认第一轮加密：0001110000100111第二轮加密：0111011001010001 轮密钥加第零轮加密，也就是对状态矩阵与密钥进行逐位的异或操作 1234567891011# 轮密钥加密：逐位进行异或操作 输入两个二进制字符串，输出结果=&gt;二进制字符串 def xor(text1, text2): i = 0 restext = &quot;&quot; while i &lt; len(text1): if text1[i] == text2[i]: restext += &quot;0&quot; else: restext += &quot;1&quot; i += 1 return restext 半字节替代代码实现如下： 12345678910111213# 半字节替代，传入二进制字符串，返回二进制字符串 def halfByteReplace(text, Box): index = 0 result = &quot;&quot; while index &lt; len(text): i = int(text[index:index + 2], 2) j = int(text[index + 2:index + 4], 2) result += Box[i][j] index += 4 # 十六进制转换二进制 result = bin(int(result, 16))[2:].zfill(16) return result 因为在这里用到了置换盒，我们需要保证正置换盒和逆置换盒之间是匹配的，所以需要进行测试： 123456# 置换盒测试程序 plainText = bin(int(&quot;8A1C&quot;, 16))[2:] print(&quot;置换盒测试&quot;) print(plainText) print(hex(int(halfByteReplace(plainText, S_Box), 2))) print(hex(int(halfByteReplace(halfByteReplace(plainText, S_Box), S_deBox), 2))) 1234置换盒测试10001010000111000x604c0x8a1c 发现置换盒确实可逆，测试通过！！！ 行移位这个很简单，直接上代码实现： 12345678910# 左循环移位，传入二进制字符串，返回二进制字符串 def left_shift(text): stateMartix = toStateMartix(text) # 交换 tem = stateMartix[1][0] stateMartix[1][0] = stateMartix[1][1] stateMartix[1][1] = tem return reStateMartix(stateMartix) 测试程序如下： 1234# 行移位测试程序 print(&quot;行移位测试&quot;) resText = halfByteReplace(plainText, S_Box) print(hex(int(left_shift(resText), 2))) 12行移位测试0x6c40 列混淆代码实现如下： 1234567891011121314151617181920212223242526272829303132def gf_add(a, b): return a ^ b # 二进制数的异或运算即为GF(2^4)的加法运算 def gf_multiply(a, b): result = 0 while b != 0: if b &amp; 1: result ^= a a &lt;&lt;= 1 if a &amp; 0x10: a ^= 0b10011 # GF(2^4)的乘法多项式 x^4 + x + 1 b &gt;&gt;= 1 return result % 16 # 结果需要模上16，因为GF(2^4)的元素是4位二进制数 # 列混淆函数，传入一个列混淆矩阵和一个二进制字符串。返回一个二进制字符串 def colMix(colMartix, byteText): myMartix = toStateMartix(byteText) resMartix = [[&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;]] resMartix[0][0] = bin(gf_add(gf_multiply(int(colMartix[0][0], 16), int(myMartix[0][0], 2)), gf_multiply(int(colMartix[0][1], 16), int(myMartix[1][0], 2))))[2:].zfill(4) resMartix[0][1] = bin(gf_add(gf_multiply(int(colMartix[0][0], 16), int(myMartix[0][1], 2)), gf_multiply(int(colMartix[0][1], 16), int(myMartix[1][1], 2))))[2:].zfill(4) resMartix[1][0] = bin(gf_add(gf_multiply(int(colMartix[1][0], 16), int(myMartix[0][0], 2)), gf_multiply(int(colMartix[1][1], 16), int(myMartix[1][0], 2))))[2:].zfill(4) resMartix[1][1] = bin(gf_add(gf_multiply(int(colMartix[1][0], 16), int(myMartix[0][1], 2)), gf_multiply(int(colMartix[1][1], 16), int(myMartix[1][1], 2))))[2:].zfill(4) return reStateMartix(resMartix) 测试程序如下： 1234567#列混淆函数确认 print(&quot;列混淆函数确认&quot;) resText=left_shift(resText) resText2 = colMix(mixMatrix,resText) print(hex(int(resText2,2))) resText3 = colMix(deMixMatrix,resText2) print(hex(int(resText3,2))) 123列混淆函数确认0x37430x6c40 加密123456789101112131415161718192021222324252627282930313233343536373839def enCrypt(plainText, key): plainText=bin(int(plainText,2))[2:].zfill(16) key = bin(int(key, 2))[2:].zfill(16) #进行密钥扩展 keyList=[key, expandKey(key, cons1, S_Box), expandKey(expandKey(key, cons1, S_Box), cons2, S_Box)] #第0轮加密：将明文与初始密文进行异或 temText=xor(plainText, keyList[0]) #第1轮加密 #1.1 半字节代替：对temText进行半字节替代 temText=halfByteReplace(temText,S_Box) #1.2 行位移 temText=left_shift(temText) #1.3 列混淆 temText=colMix(mixMatrix,temText) #1.3 轮密钥加密 temText=xor(temText, keyList[1]) #第2轮加密 #2.1 半字节替代 temText=halfByteReplace(temText,S_Box) #2.2 行位移 temText=left_shift(temText) #2.3 轮密钥加 temText=xor(temText, keyList[2]) return temText 解密12345678910111213141516171819202122232425262728293031323334353637383940def deCrypt(cyberText,key): cyberText=bin(int(cyberText,2))[2:].zfill(16) key = bin(int(key, 2))[2:].zfill(16) #将key进行扩展 keyList = [key, expandKey(key, cons1, S_Box), expandKey(expandKey(key, cons1, S_Box), cons2, S_Box)] # 第0轮解密 # 密钥加 temText=xor(cyberText,keyList[2]) #第一轮解密 #1.1 逆行移位 temText=left_shift(temText) #1.2 逆半字节替代 temText=halfByteReplace(temText,S_deBox) #1.3 轮密钥加 temText=xor(temText,keyList[1]) #1.4 逆列混淆 temText=colMix(deMixMatrix,temText) #第二轮解密 #2.1 逆行移位 temText=left_shift(temText) # 2.2 逆半字节替代 temText=halfByteReplace(temText,S_deBox) # 2.3 轮密钥加 temText=xor(temText,keyList[0]) return temText 测试函数： 12345678#加密确认 #1101111000001101 print(&quot;加密确认&quot;) print(&quot;明文为：0110111101101011&quot;) print(&quot;密文为：&quot; + enCrypt(plainText=&quot;0110111101101011&quot;, key=&quot;1010011100111011&quot;)) testcyber=enCrypt(plainText=&quot;1100110000110011&quot;, key=&quot;1010011100111011&quot;) #mystr=&quot;0000 0111 0011 1000&quot; print(&quot;解密：&quot;+deCrypt(testcyber,key=&quot;1010011100111011&quot;)) 结果如下： 1234加密确认明文为：0110111101101011密文为：0000011100111000解密：1100110000110011 加密算法扩展ASCII码扩展该功能要求对ASCII码部分进行扩展，要求将ASCII码表中的字符进行加密解密。实现逻辑很简单，就是将字符按照ASCII码表转换为二进制数，然后再进行AES加密。 代码实现如下： 123456789101112131415161718192021222324252627282930# ascii 编码的实现:传入一个字符串和密钥，返回密文数组 def asciiEnCrypt(str,key): #把一个str转换为ascList ascList=[] for i in str: ascList.append(ord(i)) cyberList=[] for i in ascList: tem=bin(i)[2:] cyberList.append(enCrypt(tem,key)) return cyberList #传入一个cyberList，返回对应的字符串数组 def asciiDeCrypt(cyberList,key): ascList=[] for i in cyberList: ascList.append(int(deCrypt(i,key),2)) strLst=[] for i in ascList: strLst.append(chr(i)) return lstToStr(strLst) #把字符串数组转换为字符串 def lstToStr(lst): str=&quot;&quot; for i in lst: str+=i return str 测试如下： 123456#ascii扩展 print(&quot;ascii扩展&quot;) str=&quot;Hello world!!!&quot; cyberlst=asciiEnCrypt(str, key=&quot;1010011100111011&quot;) print(cyberlst) print(asciiDeCrypt(cyberlst,key=&quot;1010011100111011&quot;)) 测试结果如下： 123ascii扩展['0100011111000100', '0001111010001010', '1111111010000011', '1111111010000011', '1110111010000101', '1001001000010110', '1010110100111000', '1110111010000101', '0101110100111110', '1111111010000011', '1000111010000010', '0011001000011101', '0011001000011101', '0011001000011101']Hello world!!! 暴力破解场景：给出一对或多对明文密文对，要求破解出所有可能的密钥实现逻辑，暴力循环测试，直到成功将明文加密成相同的密文 1234567891011121314#暴力破解函数,输入明文和密文，返回其对应的key数组 def breakOut(plainText,cyberText): start_time=time.time() key=0 keyLst=[] while key&lt;2**16-1: myCyber=enCrypt(plainText,bin(key)[2:]) if myCyber == cyberText: keyLst.append(key) key+=1 newkey=[] for i in keyLst: newkey.append(bin(i)[2:]) return newkey,time.time()-start_time 测试程序： 123#暴力破解 print(&quot;暴力破解&quot;) print(breakOut(&quot;0110111101101011&quot;,&quot;0000011100111000&quot;)) 预期结果： 12暴力破解(['1010010001011111', '1010011100111011'], 8.70831561088562) 多重加密用多个key对明文进行加密 1234567891011121314151617181920212223#多重加密 def multiplyEnCrypt(plainText,key): level=len(key)/16 count=0 cyberText=plainText while count&lt;level: temkey=key[0:16] key=key[16:] cyberText=enCrypt(cyberText,temkey) count+=1 return cyberText #多重解密 def multiplyDeCrypt(cyberText,key): level = len(key) / 16 count=0 plainText=cyberText while count&lt;level: temkey=key[-16:] key=key[0:-16] plainText=deCrypt(plainText,temkey) count+=1 return plainText 测试函数 12345#多重加密 print(&quot;多重加密&quot;) mulcyber=multiplyEnCrypt(&quot;0110111101101011&quot;,&quot;10100111001110110110111101101011&quot;) print(&quot;加密后的密文为：&quot;+mulcyber) print(&quot;解密后的明文为：&quot;+multiplyDeCrypt(mulcyber,&quot;10100111001110110110111101101011&quot;)) 预期结果 123多重加密加密后的密文为：0101101111011000解密后的明文为：0110111101101011","link":"/S-AES/"},{"title":"每周学习打卡！","text":"给自己记录一下就业期间的学习情况，希望30岁的时候回头看还能觉得：这个小伙子还是挺努力的😚 启动！第一周学习计划 LeetCode 30题 手写Spring实现 IOC 和 AOP 完成SaaS短链接项目1/3 实际学习情况 LeetCode 30题 手写Spring实现 IOC 和 AOP 完成SaaS短链接项目1/3 spring只做了ioc，saas短链接做了1/4。另外看了一点点JUC，自己手动实现了一个布隆过滤器 第二周学习计划 看完短链接项目剩下的3/4 lc 突破100大关 代码随想录看完二叉树和回溯 周日晚上写好简历 实际学习情况 看完短链接项目剩下的3/4 lc 突破100大关 代码随想录看完二叉树和回溯 周日晚上写好简历 周五周六周日连摆三天SaaS短链接看了一点点，每全部看完。leetcode刷到了85。因为没看完，所以就没写简历了。颓废的一周，好废物啊🤐 第三周学习计划这周真得奋进了，不然真得失业了😭 lc突破120大关 saas短链接看完 八股随缘看一些 写一篇技术博客","link":"/Weekly-Study-Plan/"},{"title":"TCP","text":"概述TCP（Transmission Control Protocol，传输控制协议）是一种在计算机网络中常用的通信协议，位于网络协议栈的传输层。它提供了可靠的、面向连接的数据传输服务，被广泛应用于互联网及局域网中各种网络通信场景。 TCP的主要特点包括： 可靠性：TCP通过序列号、确认和重传机制来确保数据的可靠传输。每个数据包都会标记一个序列号，接收方收到数据后会发送确认，发送方在一定时间内未收到确认就会重传数据，以保证数据能够正确到达。 面向连接：在进行数据传输之前，TCP会先建立连接，包括三次握手过程，确保通信双方都能正常通信。数据传输完成后，还需要进行连接的释放，包括四次挥手过程。 流量控制：TCP使用滑动窗口机制进行流量控制，确保发送方发送的数据不会超过接收方的处理能力，避免数据丢失或网络拥塞。 拥塞控制：TCP使用拥塞窗口和拥塞避免算法来控制数据在网络中的传输速率，以防止网络拥塞和丢包情况的发生，从而保证网络的稳定性和性能。 全双工通信：TCP连接是全双工的，允许双方同时发送和接收数据，实现了双向通信。 面向字节流：TCP将数据视为连续的字节流进行传输，没有消息边界的概念，接收方需要根据应用协议来解析数据。 TCP在互联网中被广泛应用于各种网络应用中，如Web浏览、文件传输、电子邮件等，其可靠性和稳定性使其成为网络通信中不可或缺的一部分。 知识要点TCP报文的首部格式 TCP报文的首部包含以下各个字段： 源端口：占16位，表示发送方的端口号。 目的端口：占16位，表示接收方的端口号。 序列号：占32位，用于对发送的数据进行排序和重组。 确认号：占32位，表示期望接收的下一个数据字节的序号。 数据偏移：占4位，表示TCP头部的长度，以32位字为单位。 保留：占6位，留待将来使用，目前必须为0。 标志位：占6位，包括URG、ACK、PSH、RST、SYN和FIN，用于控制TCP连接的建立、终止和数据传输过程。 窗口大小：占16位，表示发送方愿意接收的窗口大小，用于流量控制。 校验和：占16位，用于检测TCP首部和数据在传输过程中是否出现错误。 紧急指针：占16位，用于指示紧急数据的末尾位置。 选项：可选字段，用于在TCP头部中包含一些额外的控制信息，如选择性确认、最大报文大小等。 数据：占可变长度，用于存储应用层的数据。 这些字段共同组成了TCP报文的首部，用于在TCP通信中标识和管理数据传输。 TCP报文的标志位字段包含6个位，用于控制TCP连接的建立、终止和数据传输过程。下面是对每个标志位的介绍： URG（Urgent）：紧急指针（Urgent Pointer）有效。当此标志位被设置时，表示紧急数据存在于TCP数据流中，并且紧急指针字段指示了紧急数据的末尾位置。紧急数据用于在正常数据传输之外发送一些重要的控制信息。 ACK（Acknowledgment）：确认号（Acknowledgment Number）有效。当此标志位被设置为1时，表示确认号字段中包含的确认序列号有效，即接收方已经成功接收到了发送方期望接收的数据。 PSH（Push）：推送数据（Push）。当此标志位被设置时，表示发送方希望尽快将数据推送给接收方，而不需要等到发送缓冲区满或者等待ACK确认。 RST（Reset）：连接复位（Reset）。当此标志位被设置时，表示发生严重错误，要求对方重新建立连接。通常用于异常情况下的连接复位。 SYN（Synchronize）：同步序列号（Synchronize Sequence Numbers）。用于建立连接时的同步序列号的交换。在三次握手的过程中，SYN用于请求建立连接，并且包含了发送方的初始序列号。 FIN（Finish）：结束连接（Finish）。当此标志位被设置时，表示发送方已经没有数据要发送了，并请求关闭连接。通常用于正常的连接终止过程中。 TCP连接的建立与释放TCP连接的建立流程概述 第一次握手（SYN）： 客户端发送一个带有SYN标志位的TCP报文段，指示客户端要求建立连接。 这个报文段中包含了客户端的初始序列号（Sequence Number），用来标识客户端发送的数据。 第二次握手（SYN + ACK）： 服务器接收到客户端的SYN报文段后，会发送一个带有SYN和ACK标志位的TCP报文段作为响应。 这个报文段中确认了客户端的序列号，并且也包含了服务器的初始序列号。 第三次握手（ACK）： 客户端收到服务器的SYN + ACK报文段后，会向服务器发送一个带有ACK标志位的TCP报文段。 这个报文段中确认了服务器的序列号，表示客户端已经接受到了服务器的确认，并且连接已经建立完成。此时也可以发送应用层的数据 可不可以两次握手？ 如果一开始发送的TCP连接请求因为过去了很久很久才到达了TCP服务器，因为是两次握手，TCP服务器会直接进入连接建立状态。同时这个时候TCP服务器会不断发送响应请求，但此时TCP客户处于关闭状态，这样会造成很大的资源浪费。 TCP连接的释放流程概述TCP四次挥手的过程： 第一次挥手（FIN）： 客户端或服务器其中一方决定关闭连接，发送一个带有FIN标志位的TCP报文给对方，表示自己不再发送数据，但仍愿意接收数据。 发送方会继续发送数据直到所有数据发送完毕或达到超时时间。 第二次挥手（ACK）： 接收到第一次挥手的一方（接收方）收到FIN后，会发送一个带有ACK标志位的TCP报文，确认收到了对方的FIN，并且进入关闭等待状态。此时，该方可以继续发送数据。 第三次挥手（FIN）： 接收到第二次挥手的一方（发送方）在发送完数据后，也决定关闭连接，于是发送一个带有FIN标志位的TCP报文给对方，表示自己不再发送数据，但仍愿意接收数据。 发送方会等待接收方的确认，或者等待一段时间后主动关闭连接。 第四次挥手（ACK）： 接收到第三次挥手的一方发送一个带有ACK标志位的TCP报文给对方，确认收到了对方的FIN，并且发送方也关闭了连接。 接收方等待一段时间确认对方是否接收到了FIN，然后关闭连接。 可不可以三次挥手？如果三次挥手，那么意思是TCP客户将会在收到第三次挥手信息之后关闭，服务器将会在发送第三次挥手信息之后关闭。但是如果第三次挥手信息中途丢失了，但是服务器此时又直接关闭了，那么客户将一直拿不到最后一次的数据，也没有办法发送ack报文要求对方重传。客户机将一直挂起 为什么最后一次挥手之后还要等待2MSL 如图所示，当第四次挥手的报文丢失之后，TCP服务器会超时重传重新发送第三次挥手的报文信息，但是如果此时TCP进入关闭状态，那么TCP服务器将迟迟收不到响应，将会一直进行超时重传，所以需要等待。为什么等待的刚好是2MSL? 2MSL 的时间刚好够客户自己的报文发送出去并且丢失，加上TCP服务器超时重传的时间。 TCP流量控制 初始在建立连接的时候，双方就会确定发送窗口的大小，假设初始确定的滑动窗口大小为400. TCP拥塞控制 慢启动（Slow Start）： 在TCP连接建立或拥塞恢复时，慢启动算法将初始的拥塞窗口设置为1个报文段大小，并且每当收到一个确认就将窗口大小加倍，从而实现指数级的增长。 拥塞避免（Congestion Avoidance）： 当拥塞窗口大小达到慢启动阈值（ssthresh）时，TCP会进入拥塞避免状态。在拥塞避免状态下，拥塞窗口以线性增长的方式增加，每当一个往返时间（RTT）过去时，拥塞窗口增加一个报文段大小。 快重传（Fast Retransmit）： 如果发送方接收到对同一个数据包的三个重复的ACK确认，它会认为这个数据包已经丢失，并立即重传该数据包，而不必等待超时。 快恢复（Fast Recovery）： 当发送方收到三个重复的ACK时，它会将拥塞窗口减半（而不是将其设置为1，这与慢启动不同），并将慢启动阈值设置为当前拥塞窗口的一半。接着，它进入快速恢复状态，在此状态下，拥塞窗口每收到一个 ACK 就增加一个报文段大小，而不是每次加倍，这相对于慢启动算法来说是一种更加保守的方法。 拥塞检测并没有单独的算法，它是快重传和快恢复算法的一部分，在出现丢失的数据包时，通过快速重传和快速恢复算法来尽快检测并纠正拥塞。 TCP超时重传时间选择RTO代表重传超时时间（Retransmission TimeOut），是TCP协议中的一个重要概念。它表示在发送数据后等待确认（ACK）的时间超过RTO时，发送方认为数据丢失，并触发重传机制，重新发送未确认的数据。最近的样本RTT（Sample RTT）：发送方在收到数据的确认时记录下来的往返时间（RTT）的样本值。偏差RTT（Deviation RTT）：样本RTT与平均RTT之间的偏差，用于估计RTT的波动情况。 常见面试问题TCP连接建立后客户机突然宕机了怎么办？TCP Keep-Alive是一种TCP协议的扩展机制，用于检测TCP连接的存活状态。它通过在连接空闲时定期向对方发送探测报文来检测连接的存活性，以防止连接因为长时间的空闲而被网络设备或中间节点关闭。 TCP Keep-Alive的工作原理如下： 定时发送探测报文：一旦TCP连接空闲超过一定的时间阈值，TCP Keep-Alive机制就会启动。发送方会定期向对方发送特殊的Keep-Alive探测报文，以确认对方是否仍然处于活动状态。 等待对方响应：发送方发送Keep-Alive探测报文后，会等待一定的时间来等待对方的响应。如果对方没有响应，则表示连接可能已经失效。 关闭连接：如果在一定的等待时间内没有收到对方的响应，发送方就会认为连接已经失效，并关闭连接释放资源。这样可以及时清除无效的连接，避免资源的浪费。 TCP Keep-Alive的参数可以由操作系统或应用程序设置，包括Keep-Alive探测报文的发送间隔、空闲连接超时时间和最大尝试次数等。这些参数可以根据具体的应用场景和网络环境进行调整，以平衡连接的可靠性和性能开销。 保活计时器是TCP Keep-Alive机制中的一个关键组成部分，用于控制发送Keep-Alive探测报文的定时发送和超时等待。保活计时器通常由操作系统维护，它会在TCP连接空闲一定时间后启动，并定期发送Keep-Alive探测报文。如果在一定的时间内没有收到对方的响应，保活计时器会触发连接的关闭。","link":"/TCP/"}],"tags":[{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"代码复现","slug":"技术/代码复现","link":"/categories/%E6%8A%80%E6%9C%AF/%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"第一篇博客","slug":"生活/第一篇博客","link":"/categories/%E7%94%9F%E6%B4%BB/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"name":"计算机网络","slug":"技术/计算机网络","link":"/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"运输层","slug":"技术/计算机网络/运输层","link":"/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"}],"pages":[{"title":"about","text":"这是？这是适彼乐土的个人博客网站！本博客用于分享生活和技术，感谢关注~ 我是？沉淀中的软件开发工程师B.S. at Chongqing University Software Engineering|重庆大学 软件工程 学士Emerging Zhihu Answerer | 知乎新晋答主WeChat Chatbox Writer | 微信聊天框作家大鸟转转转酒吧-BarTender重庆大学吧 视频小编起点网黄金作家 那是？推荐电影： 信条 末代皇帝 指环王 推荐歌曲： Ruthless - The Marías Reminder - The Weeknd 推荐剧集： 爱，死亡和机器人 黑镜 你是？留下你的评论吧~","link":"/about/index.html"}]}