{"posts":[{"title":"这是我的第一篇博客！！！","text":"","link":"/My-First-Post/"},{"title":"S-AES加密算法","text":"本文将实现简单的AES加密算法，并进行简单的交叉测试，github链接：S-AES 流程概述 密钥扩展（Key Expansion）： AES算法使用的密钥长度可以是128位、192位或256位。 首先，根据密钥长度确定迭代次数，然后通过密钥扩展算法生成每一轮加密所需的子密钥。 初始轮（Initial Round）： 将明文分组与初始轮密钥（Round Key）进行XOR运算。 轮运算（Rounds）： AES算法中的加密运算是由多轮执行的，每一轮都包含四个基本步骤：字节代换（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。 字节代换（SubBytes）：通过一个固定的S盒（Substitution Box）将每个字节替换为另一个字节。 行移位（ShiftRows）：对每一行进行循环移位。第一行不变，第二行向左移动一位，第三行向左移动两位，第四行向左移动三位。 列混淆（MixColumns）：将每一列视为多项式，然后与一个固定的矩阵进行乘法，结果取模AES的模多项式。 轮密钥加（AddRoundKey）：每一轮使用的轮密钥与状态矩阵进行逐比特的XOR运算。 最终轮（Final Round）： 在最后一轮中，省略列混淆步骤，只执行字节代换、行移位和轮密钥加。 输出密文（Cipher Text）： 经过多轮处理后的状态矩阵即为加密后的密文。 S-AES的加密与解密步骤拆解定义初始常量初始常量不同，相同的key得到的密钥也不同，所以我们需要先规定一个初始常量。这些常量均可以被公开，而不会影响到密码的安全性。 1234567891011121314151617#轮常数 cons1=&quot;10000000&quot; cons2=&quot;00110000&quot; # 置换盒 S_Box = [['9', '4', 'A', 'B'], ['D', '1', '8', '5'], ['6', '2', '0', '3'], ['C', 'E', 'F', '7']] # 逆置换盒 S_deBox = [['A', '5', '9', 'B'], ['1', '7', '8', 'F'], ['6', '0', '2', '3'], ['C', '4', 'D', 'E']] mixMatrix = [['1', '4'], ['4', '1']] deMixMatrix = [['9', '2'], ['2', '9']] 密钥扩展原来的密钥需要生成多对子密钥，分别作为各轮加密步骤的子密钥。==将16位密钥分为左右两部分，每一部分各8位。记原始密钥为第0个密钥。== 在计算第i个密钥时，首先将第i-1个密钥的右半部分（8位）进行左循环移位，即将第i-1个密钥的右半部分的左右4位进行交换，再将左循环移位后的第i-1个密钥的右半部分（8位）进行S盒置换。 进行S盒置换后需要与轮常数进行异或，S-AES的轮常数定义为：第一轮加密的轮常数是【1000 0000】，第二轮加密的轮常数是【0011 0000】。 上述步骤就是示意图中函数g的步骤，将第i-1个密钥的右半部分（8位）执行完上述步骤后得到g(第i-1个密钥的右半部分)，将其与第i-1个密钥的左半部分（8位）进行异或得到第i个密钥的左半部分。 第i个密钥的右半部分由第i个密钥的左半部分与第i-1个密钥的右半部分进行异或得到。 具体实现： 12345678910111213141516171819202122232425262728293031323334#输入初始密钥，输出扩展之后的密钥 def expandKey(key,cons,Box): rightKey = key[8:] leftKey = key[0:8] # 左边的密钥由右半部分g(i-1)与左半部分异或得到 resLeft=xor(G(rightKey,cons,Box),leftKey) # 第i个密钥的右半部分由第i个密钥的左半部分与第i-1个密钥的右半部分进行异或得到 resRight=xor(resLeft,rightKey) return resLeft+resRight#密钥扩展的g函数， def G(byteText,cons,Box): #第一步进行左循环移位，将左右两个进行互换 resText=byteText[4:]+byteText[0:4] #第二步进行S盒替代 index = 0 result = &quot;&quot; while index &lt; len(resText): i = int(resText[index:index + 2], 2) j = int(resText[index + 2:index + 4], 2) result += Box[i][j] index += 4 # 十六进制转换二进制 result = bin(int(result, 16))[2:].zfill(8) #第三步，与轮常数进行异或 result=xor(result,cons) return result 测试： 12345#密钥扩展确认 cyberText=&quot;1010011100111011&quot; print(&quot;密钥扩展确认&quot;) print(&quot;第一轮加密：&quot; + expandKey(cyberText,cons1,S_Box)) print(&quot;第二轮加密：&quot; + expandKey(expandKey(cyberText,cons1,S_Box), cons2, S_Box)) 结果如下： 123密钥扩展确认第一轮加密：0001110000100111第二轮加密：0111011001010001 轮密钥加第零轮加密，也就是对状态矩阵与密钥进行逐位的异或操作 1234567891011# 轮密钥加密：逐位进行异或操作 输入两个二进制字符串，输出结果=&gt;二进制字符串 def xor(text1, text2): i = 0 restext = &quot;&quot; while i &lt; len(text1): if text1[i] == text2[i]: restext += &quot;0&quot; else: restext += &quot;1&quot; i += 1 return restext 半字节替代代码实现如下： 12345678910111213# 半字节替代，传入二进制字符串，返回二进制字符串 def halfByteReplace(text, Box): index = 0 result = &quot;&quot; while index &lt; len(text): i = int(text[index:index + 2], 2) j = int(text[index + 2:index + 4], 2) result += Box[i][j] index += 4 # 十六进制转换二进制 result = bin(int(result, 16))[2:].zfill(16) return result 因为在这里用到了置换盒，我们需要保证正置换盒和逆置换盒之间是匹配的，所以需要进行测试： 123456# 置换盒测试程序 plainText = bin(int(&quot;8A1C&quot;, 16))[2:] print(&quot;置换盒测试&quot;) print(plainText) print(hex(int(halfByteReplace(plainText, S_Box), 2))) print(hex(int(halfByteReplace(halfByteReplace(plainText, S_Box), S_deBox), 2))) 1234置换盒测试10001010000111000x604c0x8a1c 发现置换盒确实可逆，测试通过！！！ 行移位这个很简单，直接上代码实现： 12345678910# 左循环移位，传入二进制字符串，返回二进制字符串 def left_shift(text): stateMartix = toStateMartix(text) # 交换 tem = stateMartix[1][0] stateMartix[1][0] = stateMartix[1][1] stateMartix[1][1] = tem return reStateMartix(stateMartix) 测试程序如下： 1234# 行移位测试程序 print(&quot;行移位测试&quot;) resText = halfByteReplace(plainText, S_Box) print(hex(int(left_shift(resText), 2))) 12行移位测试0x6c40 列混淆代码实现如下： 1234567891011121314151617181920212223242526272829303132def gf_add(a, b): return a ^ b # 二进制数的异或运算即为GF(2^4)的加法运算 def gf_multiply(a, b): result = 0 while b != 0: if b &amp; 1: result ^= a a &lt;&lt;= 1 if a &amp; 0x10: a ^= 0b10011 # GF(2^4)的乘法多项式 x^4 + x + 1 b &gt;&gt;= 1 return result % 16 # 结果需要模上16，因为GF(2^4)的元素是4位二进制数 # 列混淆函数，传入一个列混淆矩阵和一个二进制字符串。返回一个二进制字符串 def colMix(colMartix, byteText): myMartix = toStateMartix(byteText) resMartix = [[&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;]] resMartix[0][0] = bin(gf_add(gf_multiply(int(colMartix[0][0], 16), int(myMartix[0][0], 2)), gf_multiply(int(colMartix[0][1], 16), int(myMartix[1][0], 2))))[2:].zfill(4) resMartix[0][1] = bin(gf_add(gf_multiply(int(colMartix[0][0], 16), int(myMartix[0][1], 2)), gf_multiply(int(colMartix[0][1], 16), int(myMartix[1][1], 2))))[2:].zfill(4) resMartix[1][0] = bin(gf_add(gf_multiply(int(colMartix[1][0], 16), int(myMartix[0][0], 2)), gf_multiply(int(colMartix[1][1], 16), int(myMartix[1][0], 2))))[2:].zfill(4) resMartix[1][1] = bin(gf_add(gf_multiply(int(colMartix[1][0], 16), int(myMartix[0][1], 2)), gf_multiply(int(colMartix[1][1], 16), int(myMartix[1][1], 2))))[2:].zfill(4) return reStateMartix(resMartix) 测试程序如下： 1234567#列混淆函数确认 print(&quot;列混淆函数确认&quot;) resText=left_shift(resText) resText2 = colMix(mixMatrix,resText) print(hex(int(resText2,2))) resText3 = colMix(deMixMatrix,resText2) print(hex(int(resText3,2))) 123列混淆函数确认0x37430x6c40 加密123456789101112131415161718192021222324252627282930313233343536373839def enCrypt(plainText, key): plainText=bin(int(plainText,2))[2:].zfill(16) key = bin(int(key, 2))[2:].zfill(16) #进行密钥扩展 keyList=[key, expandKey(key, cons1, S_Box), expandKey(expandKey(key, cons1, S_Box), cons2, S_Box)] #第0轮加密：将明文与初始密文进行异或 temText=xor(plainText, keyList[0]) #第1轮加密 #1.1 半字节代替：对temText进行半字节替代 temText=halfByteReplace(temText,S_Box) #1.2 行位移 temText=left_shift(temText) #1.3 列混淆 temText=colMix(mixMatrix,temText) #1.3 轮密钥加密 temText=xor(temText, keyList[1]) #第2轮加密 #2.1 半字节替代 temText=halfByteReplace(temText,S_Box) #2.2 行位移 temText=left_shift(temText) #2.3 轮密钥加 temText=xor(temText, keyList[2]) return temText 解密12345678910111213141516171819202122232425262728293031323334353637383940def deCrypt(cyberText,key): cyberText=bin(int(cyberText,2))[2:].zfill(16) key = bin(int(key, 2))[2:].zfill(16) #将key进行扩展 keyList = [key, expandKey(key, cons1, S_Box), expandKey(expandKey(key, cons1, S_Box), cons2, S_Box)] # 第0轮解密 # 密钥加 temText=xor(cyberText,keyList[2]) #第一轮解密 #1.1 逆行移位 temText=left_shift(temText) #1.2 逆半字节替代 temText=halfByteReplace(temText,S_deBox) #1.3 轮密钥加 temText=xor(temText,keyList[1]) #1.4 逆列混淆 temText=colMix(deMixMatrix,temText) #第二轮解密 #2.1 逆行移位 temText=left_shift(temText) # 2.2 逆半字节替代 temText=halfByteReplace(temText,S_deBox) # 2.3 轮密钥加 temText=xor(temText,keyList[0]) return temText 测试函数： 12345678#加密确认 #1101111000001101 print(&quot;加密确认&quot;) print(&quot;明文为：0110111101101011&quot;) print(&quot;密文为：&quot; + enCrypt(plainText=&quot;0110111101101011&quot;, key=&quot;1010011100111011&quot;)) testcyber=enCrypt(plainText=&quot;1100110000110011&quot;, key=&quot;1010011100111011&quot;) #mystr=&quot;0000 0111 0011 1000&quot; print(&quot;解密：&quot;+deCrypt(testcyber,key=&quot;1010011100111011&quot;)) 结果如下： 1234加密确认明文为：0110111101101011密文为：0000011100111000解密：1100110000110011 加密算法扩展ASCII码扩展该功能要求对ASCII码部分进行扩展，要求将ASCII码表中的字符进行加密解密。实现逻辑很简单，就是将字符按照ASCII码表转换为二进制数，然后再进行AES加密。 代码实现如下： 123456789101112131415161718192021222324252627282930# ascii 编码的实现:传入一个字符串和密钥，返回密文数组 def asciiEnCrypt(str,key): #把一个str转换为ascList ascList=[] for i in str: ascList.append(ord(i)) cyberList=[] for i in ascList: tem=bin(i)[2:] cyberList.append(enCrypt(tem,key)) return cyberList #传入一个cyberList，返回对应的字符串数组 def asciiDeCrypt(cyberList,key): ascList=[] for i in cyberList: ascList.append(int(deCrypt(i,key),2)) strLst=[] for i in ascList: strLst.append(chr(i)) return lstToStr(strLst) #把字符串数组转换为字符串 def lstToStr(lst): str=&quot;&quot; for i in lst: str+=i return str 测试如下： 123456#ascii扩展 print(&quot;ascii扩展&quot;) str=&quot;Hello world!!!&quot; cyberlst=asciiEnCrypt(str, key=&quot;1010011100111011&quot;) print(cyberlst) print(asciiDeCrypt(cyberlst,key=&quot;1010011100111011&quot;)) 测试结果如下： 123ascii扩展['0100011111000100', '0001111010001010', '1111111010000011', '1111111010000011', '1110111010000101', '1001001000010110', '1010110100111000', '1110111010000101', '0101110100111110', '1111111010000011', '1000111010000010', '0011001000011101', '0011001000011101', '0011001000011101']Hello world!!! 暴力破解场景：给出一对或多对明文密文对，要求破解出所有可能的密钥实现逻辑，暴力循环测试，直到成功将明文加密成相同的密文 1234567891011121314#暴力破解函数,输入明文和密文，返回其对应的key数组 def breakOut(plainText,cyberText): start_time=time.time() key=0 keyLst=[] while key&lt;2**16-1: myCyber=enCrypt(plainText,bin(key)[2:]) if myCyber == cyberText: keyLst.append(key) key+=1 newkey=[] for i in keyLst: newkey.append(bin(i)[2:]) return newkey,time.time()-start_time 测试程序： 123#暴力破解 print(&quot;暴力破解&quot;) print(breakOut(&quot;0110111101101011&quot;,&quot;0000011100111000&quot;)) 预期结果： 12暴力破解(['1010010001011111', '1010011100111011'], 8.70831561088562) 多重加密用多个key对明文进行加密 1234567891011121314151617181920212223#多重加密 def multiplyEnCrypt(plainText,key): level=len(key)/16 count=0 cyberText=plainText while count&lt;level: temkey=key[0:16] key=key[16:] cyberText=enCrypt(cyberText,temkey) count+=1 return cyberText #多重解密 def multiplyDeCrypt(cyberText,key): level = len(key) / 16 count=0 plainText=cyberText while count&lt;level: temkey=key[-16:] key=key[0:-16] plainText=deCrypt(plainText,temkey) count+=1 return plainText 测试函数 12345#多重加密 print(&quot;多重加密&quot;) mulcyber=multiplyEnCrypt(&quot;0110111101101011&quot;,&quot;10100111001110110110111101101011&quot;) print(&quot;加密后的密文为：&quot;+mulcyber) print(&quot;解密后的明文为：&quot;+multiplyDeCrypt(mulcyber,&quot;10100111001110110110111101101011&quot;)) 预期结果 123多重加密加密后的密文为：0101101111011000解密后的明文为：0110111101101011","link":"/S-AES/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world/"}],"tags":[{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"代码复现","slug":"代码复现","link":"/tags/%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/"}],"categories":[{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"}],"pages":[{"title":"about","text":"沉淀中的软件开发工程师B.S. at Chongqing University Software Engineering|重庆大学 软件工程 学士Emerging Zhihu Answerer | ==知乎新晋答主==WeChat Chatbox Writer | 微信聊天框作家大鸟转转转酒吧-BarTender重庆大学吧 视频小编 推荐电影： 信条 末代皇帝 指环王 推荐歌曲： Ruthless - The Marías Reminder - The Weeknd 推荐剧集： 爱，死亡和机器人 黑镜","link":"/about/index.html"}]}