{"posts":[{"title":"自定义实现布隆过滤器","text":"布隆过滤器是一种数据结构，用于快速判断一个元素是否存在于一个集合中。它以牺牲一定的准确性为代价，来降低在大规模数据集中的查询时间。 布隆过滤器利用一系列哈希函数和一个比特数组来实现。当元素被添加到布隆过滤器中时，相应的哈希函数会将其映射到比特数组的多个位置上。查询时，如果元素对应的所有位置都被置为1，则说明元素可能存在于集合中；否则，元素一定不存在。 尽管布隆过滤器具有一定的误判率，但它具有很高的查询速度和空间效率，特别适用于需要快速判断某个元素是否属于一个大规模数据集的场景，比如网络爬虫中的URL去重、缓存中的数据查询等。 在Java中，我们可以通过实现布隆过滤器来有效地处理大规模数据集。使用合适的哈希函数和比特数组大小，可以平衡布隆过滤器的空间占用和查询性能。 在接下来的博客中，我们将深入探讨如何使用Java语言实现布隆过滤器，以及如何在实际应用中有效地利用它来提升系统的性能和效率。github链接：YugBloomFilter 介绍快速启动布隆过滤器常用于解决缓存穿透问题，平常我们可以使用Google Guava库中的BloomFilter类、Apache Commons库中的BloomFilter类等来创建布隆过滤器，示例代码如下 123456789101112131415public class BloomFilterExample { public static void main(String[] args) { // 创建布隆过滤器，预期数据量为1000，误判率为0.01 BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), 1000, 0.01); // 添加元素到布隆过滤器 bloomFilter.put(123); bloomFilter.put(456); bloomFilter.put(789); // 检查元素是否存在于布隆过滤器中 System.out.println(bloomFilter.mightContain(123)); // true System.out.println(bloomFilter.mightContain(999)); // false }} 原理布隆过滤器可以看作是一个bits为n的ditmap，同时有k个哈希函数。当一个元素加入位图时，通过k个hash函数将元素映射到位图的k个点，并把它们置1；当检索时，再通过k个hash函数运算检查位图的k个点是否都为1；如果有不为1的点，那么认为该key不存在；如果全部为1，则可能存在。同时可能存在误判的情况，即k个点均为1，而实际上该key并不存在布隆过滤器中。布隆过滤器的误判率，主要取决于bitmap的大小和hash函数的个数以及设计。正常我们在使用布隆过滤器的时候，是给定预期数据量n和误判率p，然后动态生成我们所需要的布隆过滤器。计算公式如下：$$m = \\lceil \\frac{n \\cdot \\log(p)}{\\log\\left(\\frac{1}{2^{\\log(2)}}\\right)} \\rceil$$$$k = \\text{round}\\left(\\frac{m}{n} \\cdot \\log(2)\\right)$$得到bitmap的大小m和所需哈希函数个数之后，我们便可以开始构造属于我们的布隆过滤器了 代码实现定义布隆过滤器接口在这里我们定义布隆过滤器的接口类，方便程序的扩展和后续的使用 1234567public interface BloomFilter { //添加元素 public void add(Object value); //判断某元素是否存在 public boolean contains(Object value); } 实现简单布隆过滤器该简单布隆过滤器接受bitma的大小和hash函数的个数以进行初始化 1234567891011121314/** * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样 */public SimpleBloomFilter(int size, int k) { this.size=size; this.k=k; this.bits = new BitSet(size); // 根据k的值获得k个种子数组 SEEDS = PrimeNumbers.getKDistinctPrimes(k); // 根据k个种子创建k个哈希函数并添加到数组中 for(int i : SEEDS){ func.add(new SimpleHash(size,i)); }} 属性定义： 123456789101112131415161718192021222324/** * 位数组的大小 */ private int size; /** * SimpleHash Function 的个数 */ private int k; /** * 通过这个数组可以创建 多 个不同的哈希函数 */ private List&lt;Integer&gt; SEEDS ; /** * 位数组。数组中的元素只能是 0 或者 1 */ private BitSet bits ; /** * 存放包含 hash 函数的类的数组 */ private ArrayList&lt;SimpleHash&gt; func = new ArrayList&lt;&gt;(); 定义哈希类根据上文所述，我们需要k个哈希函数，在此我们定义一个SimpleHash类，给定bitmap容量和随机数种子之后可以动态的生成一个hash函数注意： 需要给定bitmap的容量是因为我们的hash函数生成的hashcode的范围应该在（0,m-1） 种子最好为质数 12345678910111213141516171819public static class SimpleHash { private int cap; private int seed; public SimpleHash(int cap, int seed) { this.cap = cap; this.seed = seed; } /** * 计算 hash 值 */ public int hash(Object value) { int h; return (value == null) ? 0 : Math.abs(seed * (cap - 1) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; 16))); }} 质数生成器我们需要一个相对均匀的质数数组，所以我们实现一个简单的质数生成器，每个质数之间的间隔大于20，以确保它相对来说均匀 12345678910111213141516171819202122232425262728293031public class PrimeNumbers { public static List&lt;Integer&gt; getKDistinctPrimes(int k) { List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); int num = 2; while (primes.size() &lt; k) { if (isPrime(num) &amp;&amp; isWellDistributed(num, primes)) { primes.add(num); } num++; } return primes; } private static boolean isPrime(int num) { /** * 省略代码实现 */ } private static boolean isWellDistributed(int num, List&lt;Integer&gt; primes) { for (int prime : primes) { if (Math.abs(prime - num) &lt; 20) { // 设置一个距离阈值，确保质数之间距离较远 return false; } } return true; }} 实现布隆过滤器接口初始化完毕之后，便需要实现布隆过滤器的接口，实现add和contains功能 12345678910111213141516171819/** * 添加元素到位数组 */public void add(Object value) { for (SimpleHash f : func) { bits.set(f.hash(value), true); }}/** * 判断指定元素是否存在于位数组 */public boolean contains(Object value) { boolean ret = true; for (SimpleHash f : func) { ret = ret &amp;&amp; bits.get(f.hash(value)); } return ret;} 实现布隆过滤器工厂布隆过滤器工厂接收预期数据量n和误差率p，根据上面两个数据计算出布隆过滤器的大小m(size)和哈希函数个数k。通过布隆过滤器工厂创建布隆过滤器可以简化布隆过滤器的使用 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435/** * 布隆过滤器的工厂，用于创建布隆过滤器 * 给定 预期数据量 n 和误差率 p 计算得到所需布隆过滤器的 size 和哈希函数个数 k */public class BloomFilterFactory { /** * 创建普通布隆过滤器 * @param n * @param p * @return */ public static BloomFilter createBloomFilter(int n, double p){ int size = getSizeOfBloomFilter(n,p); int k =getNumberOfHashFuc(size,n); return new SimpleBloomFilter(size,k); } /** * 根据传入的数据量 n 和 误差率 p返回size * @return */ private static int getSizeOfBloomFilter(int n, double p) { int size = (int) Math.ceil(-(n * Math.log(p)) / Math.pow(Math.log(2), 2)); return size; } /** * 根据传入的 size 和 数据量 n 返回所需的哈希函数值 * @return */ private static int getNumberOfHashFuc(int size, int n) { int k = (int) Math.ceil((size / (double) n) * Math.log(2)); return k; }} 程序中实际应用布隆过滤器程序执行逻辑梳理：请求到来之后在Server到Redis之间插入布隆过滤器，先判断数据是否存在，存在再执行接下来的步骤，不存在则直接返回。同时在每次查询到数据结果之后，布隆过滤器添加该key。代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344BloomFilter myBloomFilter = BloomFilterFactory.createBloomFilter(1000,0.001);/** * 初始化布隆过滤器，将数据库中的数据初始化进入布隆过滤器中 */@PostConstructpublic void init(){ List&lt;Shop&gt; shops = shopMapper.selectList(null); for (Shop shop : shops){ myBloomFilter.add(shop.getId()); }}@Overridepublic Result queryById(Long id) { //先从布隆过滤中判断是否有这个数据 if(!myBloomFilter.contains(id)){ return Result.fail(&quot;不包含这个id&quot;); } String key = &quot;cache:shop:&quot; + id; // 1. 从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 2. 判断是否存在 if (StrUtil.isNotBlank(shopJson)){ // 3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); myBloomFilter.add(shop.getId()); return Result.ok(shop); } // 4.不存在，根据id查询数据库 Shop shop = getById(id); myBloomFilter.add(shop.getId()); // 5.不存在，返回错误 if (shop == null){ return Result.fail(&quot;商铺不存在！&quot;); } // 6.存在，写入redis,并设置过期时间 stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop)); //设置30+1~5 mins的过期时间，以解决缓存雪崩问题 stringRedisTemplate.expire(key,30+RANDOM_EXPIRE_TIME, TimeUnit.MINUTES); return Result.ok(shop);} 拓展：自扩容布隆过滤器当布隆过滤器实际的数据存储量超过预期数据量之后，误判率也会随之上涨。但是布隆过滤器是不能删除已有元素的，在这里我们采取的方案是再创建一个布隆过滤器添加操作在最新的布隆过滤器中执行，contain操作在所有的布隆过滤器中执行代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 自适应布隆过滤器，当满了的时候实现自动扩容 */public class AdaptBloomFilter implements BloomFilter{ private int n; private double p; public AdaptBloomFilter(int n, double p){ this.n=n; this.p=p; this.bloomList.add(BloomFilterFactory.createBloomFilter(n,p)); } // 布隆过滤器列表 private ArrayList&lt;BloomFilter&gt; bloomList = new ArrayList&lt;&gt;();; //此布隆过滤器实现 private int count=0; @Override public void add(Object value) { // 向最后的一个布隆过滤器添加 bloomList.get(bloomList.size()-1).add(value); if (count++&gt;n){ expand(); } } @Override public boolean contains(Object value) { // 遍历每个布隆过滤器判断是否存在 for (BloomFilter i : bloomList){ if (bloomList.contains(value)){ return true; } } return false; } private void expand(){ this.bloomList.add(BloomFilterFactory.createBloomFilter((int) (n*0.5),p)); }}","link":"/BloomFilter/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world/"},{"title":"S-AES加密算法","text":"AES（Advanced Encryption Standard）是一种常用的对称加密算法，用于保护数据的安全性。Python提供了丰富的库和模块，使得实现AES加密算法变得简单而高效。通过使用Python中的cryptography库或者pycryptodome库，我们可以轻松地实现AES加密算法，并对数据进行加密和解密操作。 在接下来的博客中，我们将详细介绍如何使用Python语言实现AES加密算法。我们将学习如何生成密钥、执行加密和解密操作，以及如何处理加密数据。通过深入研究Python中AES算法的实现，我们将更好地理解数据加密的原理和实践，从而保障数据的安全性和机密性。github链接：S-AES 流程概述 密钥扩展（Key Expansion）： AES算法使用的密钥长度可以是128位、192位或256位。 首先，根据密钥长度确定迭代次数，然后通过密钥扩展算法生成每一轮加密所需的子密钥。 初始轮（Initial Round）： 将明文分组与初始轮密钥（Round Key）进行XOR运算。 轮运算（Rounds）： AES算法中的加密运算是由多轮执行的，每一轮都包含四个基本步骤：字节代换（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。 字节代换（SubBytes）：通过一个固定的S盒（Substitution Box）将每个字节替换为另一个字节。 行移位（ShiftRows）：对每一行进行循环移位。第一行不变，第二行向左移动一位，第三行向左移动两位，第四行向左移动三位。 列混淆（MixColumns）：将每一列视为多项式，然后与一个固定的矩阵进行乘法，结果取模AES的模多项式。 轮密钥加（AddRoundKey）：每一轮使用的轮密钥与状态矩阵进行逐比特的XOR运算。 最终轮（Final Round）： 在最后一轮中，省略列混淆步骤，只执行字节代换、行移位和轮密钥加。 输出密文（Cipher Text）： 经过多轮处理后的状态矩阵即为加密后的密文。 S-AES的加密与解密步骤拆解定义初始常量初始常量不同，相同的key得到的密钥也不同，所以我们需要先规定一个初始常量。这些常量均可以被公开，而不会影响到密码的安全性。 1234567891011121314151617#轮常数 cons1=&quot;10000000&quot; cons2=&quot;00110000&quot; # 置换盒 S_Box = [['9', '4', 'A', 'B'], ['D', '1', '8', '5'], ['6', '2', '0', '3'], ['C', 'E', 'F', '7']] # 逆置换盒 S_deBox = [['A', '5', '9', 'B'], ['1', '7', '8', 'F'], ['6', '0', '2', '3'], ['C', '4', 'D', 'E']] mixMatrix = [['1', '4'], ['4', '1']] deMixMatrix = [['9', '2'], ['2', '9']] 密钥扩展原来的密钥需要生成多对子密钥，分别作为各轮加密步骤的子密钥。==将16位密钥分为左右两部分，每一部分各8位。记原始密钥为第0个密钥。== 在计算第i个密钥时，首先将第i-1个密钥的右半部分（8位）进行左循环移位，即将第i-1个密钥的右半部分的左右4位进行交换，再将左循环移位后的第i-1个密钥的右半部分（8位）进行S盒置换。 进行S盒置换后需要与轮常数进行异或，S-AES的轮常数定义为：第一轮加密的轮常数是【1000 0000】，第二轮加密的轮常数是【0011 0000】。 上述步骤就是示意图中函数g的步骤，将第i-1个密钥的右半部分（8位）执行完上述步骤后得到g(第i-1个密钥的右半部分)，将其与第i-1个密钥的左半部分（8位）进行异或得到第i个密钥的左半部分。 第i个密钥的右半部分由第i个密钥的左半部分与第i-1个密钥的右半部分进行异或得到。 具体实现： 12345678910111213141516171819202122232425262728293031323334#输入初始密钥，输出扩展之后的密钥 def expandKey(key,cons,Box): rightKey = key[8:] leftKey = key[0:8] # 左边的密钥由右半部分g(i-1)与左半部分异或得到 resLeft=xor(G(rightKey,cons,Box),leftKey) # 第i个密钥的右半部分由第i个密钥的左半部分与第i-1个密钥的右半部分进行异或得到 resRight=xor(resLeft,rightKey) return resLeft+resRight#密钥扩展的g函数， def G(byteText,cons,Box): #第一步进行左循环移位，将左右两个进行互换 resText=byteText[4:]+byteText[0:4] #第二步进行S盒替代 index = 0 result = &quot;&quot; while index &lt; len(resText): i = int(resText[index:index + 2], 2) j = int(resText[index + 2:index + 4], 2) result += Box[i][j] index += 4 # 十六进制转换二进制 result = bin(int(result, 16))[2:].zfill(8) #第三步，与轮常数进行异或 result=xor(result,cons) return result 测试： 12345#密钥扩展确认 cyberText=&quot;1010011100111011&quot; print(&quot;密钥扩展确认&quot;) print(&quot;第一轮加密：&quot; + expandKey(cyberText,cons1,S_Box)) print(&quot;第二轮加密：&quot; + expandKey(expandKey(cyberText,cons1,S_Box), cons2, S_Box)) 结果如下： 123密钥扩展确认第一轮加密：0001110000100111第二轮加密：0111011001010001 轮密钥加第零轮加密，也就是对状态矩阵与密钥进行逐位的异或操作 1234567891011# 轮密钥加密：逐位进行异或操作 输入两个二进制字符串，输出结果=&gt;二进制字符串 def xor(text1, text2): i = 0 restext = &quot;&quot; while i &lt; len(text1): if text1[i] == text2[i]: restext += &quot;0&quot; else: restext += &quot;1&quot; i += 1 return restext 半字节替代代码实现如下： 12345678910111213# 半字节替代，传入二进制字符串，返回二进制字符串 def halfByteReplace(text, Box): index = 0 result = &quot;&quot; while index &lt; len(text): i = int(text[index:index + 2], 2) j = int(text[index + 2:index + 4], 2) result += Box[i][j] index += 4 # 十六进制转换二进制 result = bin(int(result, 16))[2:].zfill(16) return result 因为在这里用到了置换盒，我们需要保证正置换盒和逆置换盒之间是匹配的，所以需要进行测试： 123456# 置换盒测试程序 plainText = bin(int(&quot;8A1C&quot;, 16))[2:] print(&quot;置换盒测试&quot;) print(plainText) print(hex(int(halfByteReplace(plainText, S_Box), 2))) print(hex(int(halfByteReplace(halfByteReplace(plainText, S_Box), S_deBox), 2))) 1234置换盒测试10001010000111000x604c0x8a1c 发现置换盒确实可逆，测试通过！！！ 行移位这个很简单，直接上代码实现： 12345678910# 左循环移位，传入二进制字符串，返回二进制字符串 def left_shift(text): stateMartix = toStateMartix(text) # 交换 tem = stateMartix[1][0] stateMartix[1][0] = stateMartix[1][1] stateMartix[1][1] = tem return reStateMartix(stateMartix) 测试程序如下： 1234# 行移位测试程序 print(&quot;行移位测试&quot;) resText = halfByteReplace(plainText, S_Box) print(hex(int(left_shift(resText), 2))) 12行移位测试0x6c40 列混淆代码实现如下： 1234567891011121314151617181920212223242526272829303132def gf_add(a, b): return a ^ b # 二进制数的异或运算即为GF(2^4)的加法运算 def gf_multiply(a, b): result = 0 while b != 0: if b &amp; 1: result ^= a a &lt;&lt;= 1 if a &amp; 0x10: a ^= 0b10011 # GF(2^4)的乘法多项式 x^4 + x + 1 b &gt;&gt;= 1 return result % 16 # 结果需要模上16，因为GF(2^4)的元素是4位二进制数 # 列混淆函数，传入一个列混淆矩阵和一个二进制字符串。返回一个二进制字符串 def colMix(colMartix, byteText): myMartix = toStateMartix(byteText) resMartix = [[&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;]] resMartix[0][0] = bin(gf_add(gf_multiply(int(colMartix[0][0], 16), int(myMartix[0][0], 2)), gf_multiply(int(colMartix[0][1], 16), int(myMartix[1][0], 2))))[2:].zfill(4) resMartix[0][1] = bin(gf_add(gf_multiply(int(colMartix[0][0], 16), int(myMartix[0][1], 2)), gf_multiply(int(colMartix[0][1], 16), int(myMartix[1][1], 2))))[2:].zfill(4) resMartix[1][0] = bin(gf_add(gf_multiply(int(colMartix[1][0], 16), int(myMartix[0][0], 2)), gf_multiply(int(colMartix[1][1], 16), int(myMartix[1][0], 2))))[2:].zfill(4) resMartix[1][1] = bin(gf_add(gf_multiply(int(colMartix[1][0], 16), int(myMartix[0][1], 2)), gf_multiply(int(colMartix[1][1], 16), int(myMartix[1][1], 2))))[2:].zfill(4) return reStateMartix(resMartix) 测试程序如下： 1234567#列混淆函数确认 print(&quot;列混淆函数确认&quot;) resText=left_shift(resText) resText2 = colMix(mixMatrix,resText) print(hex(int(resText2,2))) resText3 = colMix(deMixMatrix,resText2) print(hex(int(resText3,2))) 123列混淆函数确认0x37430x6c40 加密123456789101112131415161718192021222324252627282930313233343536373839def enCrypt(plainText, key): plainText=bin(int(plainText,2))[2:].zfill(16) key = bin(int(key, 2))[2:].zfill(16) #进行密钥扩展 keyList=[key, expandKey(key, cons1, S_Box), expandKey(expandKey(key, cons1, S_Box), cons2, S_Box)] #第0轮加密：将明文与初始密文进行异或 temText=xor(plainText, keyList[0]) #第1轮加密 #1.1 半字节代替：对temText进行半字节替代 temText=halfByteReplace(temText,S_Box) #1.2 行位移 temText=left_shift(temText) #1.3 列混淆 temText=colMix(mixMatrix,temText) #1.3 轮密钥加密 temText=xor(temText, keyList[1]) #第2轮加密 #2.1 半字节替代 temText=halfByteReplace(temText,S_Box) #2.2 行位移 temText=left_shift(temText) #2.3 轮密钥加 temText=xor(temText, keyList[2]) return temText 解密12345678910111213141516171819202122232425262728293031323334353637383940def deCrypt(cyberText,key): cyberText=bin(int(cyberText,2))[2:].zfill(16) key = bin(int(key, 2))[2:].zfill(16) #将key进行扩展 keyList = [key, expandKey(key, cons1, S_Box), expandKey(expandKey(key, cons1, S_Box), cons2, S_Box)] # 第0轮解密 # 密钥加 temText=xor(cyberText,keyList[2]) #第一轮解密 #1.1 逆行移位 temText=left_shift(temText) #1.2 逆半字节替代 temText=halfByteReplace(temText,S_deBox) #1.3 轮密钥加 temText=xor(temText,keyList[1]) #1.4 逆列混淆 temText=colMix(deMixMatrix,temText) #第二轮解密 #2.1 逆行移位 temText=left_shift(temText) # 2.2 逆半字节替代 temText=halfByteReplace(temText,S_deBox) # 2.3 轮密钥加 temText=xor(temText,keyList[0]) return temText 测试函数： 12345678#加密确认 #1101111000001101 print(&quot;加密确认&quot;) print(&quot;明文为：0110111101101011&quot;) print(&quot;密文为：&quot; + enCrypt(plainText=&quot;0110111101101011&quot;, key=&quot;1010011100111011&quot;)) testcyber=enCrypt(plainText=&quot;1100110000110011&quot;, key=&quot;1010011100111011&quot;) #mystr=&quot;0000 0111 0011 1000&quot; print(&quot;解密：&quot;+deCrypt(testcyber,key=&quot;1010011100111011&quot;)) 结果如下： 1234加密确认明文为：0110111101101011密文为：0000011100111000解密：1100110000110011 加密算法扩展ASCII码扩展该功能要求对ASCII码部分进行扩展，要求将ASCII码表中的字符进行加密解密。实现逻辑很简单，就是将字符按照ASCII码表转换为二进制数，然后再进行AES加密。 代码实现如下： 123456789101112131415161718192021222324252627282930# ascii 编码的实现:传入一个字符串和密钥，返回密文数组 def asciiEnCrypt(str,key): #把一个str转换为ascList ascList=[] for i in str: ascList.append(ord(i)) cyberList=[] for i in ascList: tem=bin(i)[2:] cyberList.append(enCrypt(tem,key)) return cyberList #传入一个cyberList，返回对应的字符串数组 def asciiDeCrypt(cyberList,key): ascList=[] for i in cyberList: ascList.append(int(deCrypt(i,key),2)) strLst=[] for i in ascList: strLst.append(chr(i)) return lstToStr(strLst) #把字符串数组转换为字符串 def lstToStr(lst): str=&quot;&quot; for i in lst: str+=i return str 测试如下： 123456#ascii扩展 print(&quot;ascii扩展&quot;) str=&quot;Hello world!!!&quot; cyberlst=asciiEnCrypt(str, key=&quot;1010011100111011&quot;) print(cyberlst) print(asciiDeCrypt(cyberlst,key=&quot;1010011100111011&quot;)) 测试结果如下： 123ascii扩展['0100011111000100', '0001111010001010', '1111111010000011', '1111111010000011', '1110111010000101', '1001001000010110', '1010110100111000', '1110111010000101', '0101110100111110', '1111111010000011', '1000111010000010', '0011001000011101', '0011001000011101', '0011001000011101']Hello world!!! 暴力破解场景：给出一对或多对明文密文对，要求破解出所有可能的密钥实现逻辑，暴力循环测试，直到成功将明文加密成相同的密文 1234567891011121314#暴力破解函数,输入明文和密文，返回其对应的key数组 def breakOut(plainText,cyberText): start_time=time.time() key=0 keyLst=[] while key&lt;2**16-1: myCyber=enCrypt(plainText,bin(key)[2:]) if myCyber == cyberText: keyLst.append(key) key+=1 newkey=[] for i in keyLst: newkey.append(bin(i)[2:]) return newkey,time.time()-start_time 测试程序： 123#暴力破解 print(&quot;暴力破解&quot;) print(breakOut(&quot;0110111101101011&quot;,&quot;0000011100111000&quot;)) 预期结果： 12暴力破解(['1010010001011111', '1010011100111011'], 8.70831561088562) 多重加密用多个key对明文进行加密 1234567891011121314151617181920212223#多重加密 def multiplyEnCrypt(plainText,key): level=len(key)/16 count=0 cyberText=plainText while count&lt;level: temkey=key[0:16] key=key[16:] cyberText=enCrypt(cyberText,temkey) count+=1 return cyberText #多重解密 def multiplyDeCrypt(cyberText,key): level = len(key) / 16 count=0 plainText=cyberText while count&lt;level: temkey=key[-16:] key=key[0:-16] plainText=deCrypt(plainText,temkey) count+=1 return plainText 测试函数 12345#多重加密 print(&quot;多重加密&quot;) mulcyber=multiplyEnCrypt(&quot;0110111101101011&quot;,&quot;10100111001110110110111101101011&quot;) print(&quot;加密后的密文为：&quot;+mulcyber) print(&quot;解密后的明文为：&quot;+multiplyDeCrypt(mulcyber,&quot;10100111001110110110111101101011&quot;)) 预期结果 123多重加密加密后的密文为：0101101111011000解密后的明文为：0110111101101011","link":"/S-AES/"}],"tags":[{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"代码复现","slug":"代码复现","link":"/tags/%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/"}],"categories":[{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"}],"pages":[{"title":"about","text":"这是？这是适彼乐土的个人博客网站！本博客用于分享生活和技术，感谢关注~ 我是？沉淀中的软件开发工程师B.S. at Chongqing University Software Engineering|重庆大学 软件工程 学士Emerging Zhihu Answerer | 知乎新晋答主WeChat Chatbox Writer | 微信聊天框作家大鸟转转转酒吧-BarTender重庆大学吧 视频小编起点网黄金作家 那是？推荐电影： 信条 末代皇帝 指环王 推荐歌曲： Ruthless - The Marías Reminder - The Weeknd 推荐剧集： 爱，死亡和机器人 黑镜 你是？留下你的评论吧~","link":"/about/index.html"}]}